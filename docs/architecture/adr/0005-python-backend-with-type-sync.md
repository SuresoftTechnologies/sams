# ADR-0005: Python Backend with OpenAPI Type Synchronization

**Status**: Accepted
**Date**: 2025-10-29
**Decision Makers**: Architecture Team
**Supersedes**: ADR-0001 (Backend technology choice)

## Context

The project requires a backend API server for the SureSoft Asset Management System. We had two primary options:

1. **NestJS**: TypeScript-based framework with native type sharing
2. **Python/FastAPI**: Python framework with OpenAPI-based type generation

### Requirements

- Type safety between frontend and backend
- Rapid development for hackathon timeline
- Team expertise and productivity
- Strong ecosystem for data processing and integrations
- Auto-generated API documentation

## Decision

**We will use Python with FastAPI for the backend, with OpenAPI → TypeScript type synchronization.**

### Type Synchronization Strategy

```
Backend (Python/FastAPI)
  ↓ generates
OpenAPI Specification (openapi.json)
  ↓ converts via openapi-typescript
TypeScript Types & API Client
  ↓ consumed by
Frontend (React/TypeScript)
```

## Rationale

### Why Python/FastAPI

1. **Team Expertise**: Python is familiar for rapid prototyping
2. **FastAPI Advantages**:
   - Auto-generates OpenAPI 3.0 specs from Pydantic models
   - Built-in async support (ASGI)
   - Excellent performance (comparable to Node.js)
   - Automatic interactive API docs (Swagger UI)
3. **Rich Ecosystem**:
   - Excel processing: `openpyxl`, `pandas`
   - QR code: `qrcode`, `Pillow`
   - PDF generation: `reportlab`, `weasyprint`
   - Data analysis: `numpy`, `pandas`
4. **Type Safety via Pydantic**:
   - Runtime validation + OpenAPI generation
   - Similar DX to TypeScript

### Type Synchronization Approach

We will use a **hybrid type architecture**:

#### 1. Manual Shared Types (`@sams/shared-types`)
- Business enums (AssetStatus, UserRole, etc.)
- Domain-specific constants
- Common utility types
- These are manually maintained and shared

#### 2. Auto-Generated API Types (`@sams/api-client`)
- Generated from FastAPI's OpenAPI spec
- Request/Response DTOs
- API client functions
- Auto-generated on every backend build

### Tooling

- **openapi-typescript**: Convert OpenAPI → TypeScript types
- **openapi-fetch**: Type-safe fetch client from OpenAPI
- **Pydantic v2**: Python models with OpenAPI generation

## Implementation

### Package Structure

```
packages/
├── shared-types/          # Manual shared types
│   ├── src/
│   │   ├── enums.ts       # AssetStatus, UserRole, etc.
│   │   ├── constants.ts   # Business constants
│   │   └── common.ts      # Utility types
│   └── package.json
│
└── api-client/            # Auto-generated
    ├── openapi.json       # Generated by FastAPI
    ├── src/
    │   ├── generated/     # Auto-generated (git-ignored)
    │   │   ├── types.ts
    │   │   └── client.ts
    │   └── index.ts       # Re-exports
    ├── scripts/
    │   └── generate.ts    # Run openapi-typescript
    └── package.json
```

### Backend (FastAPI)

```python
# apps/backend/src/schemas/asset.py
from pydantic import BaseModel
from enum import Enum

class AssetStatus(str, Enum):
    """Asset status enum - based on actual Excel data."""
    ISSUED = "issued"  # [지급장비] - 직원에게 지급된 장비
    LOANED = "loaned"  # [대여용] - 대여 가능한 장비
    GENERAL = "general"  # [일반장비] - 일반 사용 장비
    STOCK = "stock"  # [재고] - 재고/보관 중
    SERVER_ROOM = "server_room"  # [서버실] - 서버실 장비
    DISPOSED = "disposed"  # [불용] - 폐기/불용 처리

class CreateAssetDto(BaseModel):
    asset_tag: str
    name: str
    category_id: str
    status: AssetStatus = AssetStatus.STOCK

    model_config = {
        "json_schema_extra": {
            "example": {
                "asset_tag": "SRS-11-2024-0001",
                "name": "Dell Latitude 5420",
                "category_id": "uuid-here",
                "status": "stock"
            }
        }
    }
```

### OpenAPI Generation

```python
# apps/backend/src/main.py
from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi
import json

app = FastAPI()

# ... routes ...

# Export OpenAPI spec
@app.on_event("startup")
async def export_openapi():
    with open("../../packages/api-client/openapi.json", "w") as f:
        json.dump(
            get_openapi(
                title="SureSoft SSAMS API",
                version="1.0.0",
                routes=app.routes,
            ),
            f,
            indent=2
        )
```

### Frontend Usage

```typescript
// apps/frontend/src/services/assets.ts
import { components, operations } from '@sams/api-client';
import { AssetStatus } from '@sams/shared-types';

type Asset = components['schemas']['Asset'];
type CreateAssetDto = components['schemas']['CreateAssetDto'];

async function createAsset(data: CreateAssetDto): Promise<Asset> {
  const response = await fetch('/api/assets', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  });
  return response.json();
}
```

### Turborepo Pipeline

```json
{
  "pipeline": {
    "generate:openapi": {
      "dependsOn": ["^build"],
      "outputs": ["../../packages/api-client/openapi.json"]
    },
    "generate:types": {
      "dependsOn": ["^generate:openapi"],
      "outputs": ["src/generated/**"]
    },
    "dev": {
      "dependsOn": [
        "@sams/backend#generate:openapi",
        "@sams/api-client#generate:types"
      ],
      "persistent": true
    }
  }
}
```

## Alternatives Considered

### Alternative 1: NestJS (Pure TypeScript)

**Pros**:
- Native TypeScript type sharing
- No code generation needed
- Consistent language across stack
- Decorators similar to FastAPI

**Cons**:
- Less familiar to team
- Weaker ecosystem for data processing
- No Prisma ORM for Python use cases

**Verdict**: Rejected due to team expertise and timeline constraints

### Alternative 2: tRPC

**Pros**:
- End-to-end type safety without code generation
- Excellent DX for TypeScript monorepos

**Cons**:
- Requires Node.js backend
- Not suitable for Python backend choice

**Verdict**: Not applicable with Python backend

### Alternative 3: Manual Type Duplication

**Pros**:
- Full control over types
- No tooling dependencies

**Cons**:
- High maintenance burden
- Easy to get out of sync
- Error-prone

**Verdict**: Rejected - violates DRY principle

## Consequences

### Positive

✅ **Fast Development**: Python's productivity for hackathon timeline
✅ **Type Safety**: OpenAPI → TypeScript preserves type safety
✅ **Auto Documentation**: Swagger UI comes free with FastAPI
✅ **Rich Ecosystem**: Access to Python libraries for data processing
✅ **Validation**: Pydantic provides runtime validation
✅ **Maintainability**: Types auto-sync on backend changes

### Negative

⚠️ **Build Complexity**: Extra step for type generation
⚠️ **Tooling Setup**: Need openapi-typescript configuration
⚠️ **Hybrid Types**: Two sources of truth (shared-types + api-client)
⚠️ **Deployment**: Need Python runtime (vs Node-only stack)

### Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Type sync breaks | CI checks for type generation success |
| OpenAPI schema drift | Automated tests validate schema |
| Team unfamiliarity with tools | Documentation + examples |
| Runtime type mismatches | Pydantic validation catches errors |

## Migration Path

This decision requires:

1. ✅ Create ADR-0005 (this document)
2. ⬜ Set up FastAPI backend scaffold
3. ⬜ Configure openapi-typescript in api-client package
4. ⬜ Update turbo.json with generation pipeline
5. ⬜ Create Pydantic models matching shared-types
6. ⬜ Implement OpenAPI export endpoint
7. ⬜ Add type generation to CI/CD

## References

- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [Pydantic v2 Docs](https://docs.pydantic.dev/latest/)
- [openapi-typescript](https://github.com/drwpow/openapi-typescript)
- [OpenAPI 3.0 Specification](https://swagger.io/specification/)
- [ADR-0001: Technology Stack Selection](./0001-technology-stack-selection.md)
- [ADR-0004: Turborepo Monorepo](./0004-turborepo-monorepo.md)

## Notes

- This approach is proven in production (Stripe, GitHub, Twilio use similar patterns)
- FastAPI's auto-generated OpenAPI is highly reliable
- Type generation can run in watch mode for dev (instant feedback)
- Python's async/await with ASGI matches Node.js performance

---

**Approved by**: Architecture Team
**Implementation Start**: 2025-10-29
